<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banker Box Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Space Mono', monospace;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        const BankerBoxGenerator = () => {
            const defaultDimensions = {
                width: 150,
                depth: 100,
                height: 80,
                lidHeight: 25,
                materialThickness: 2,
                tabWidth: 15,
                tabSpacing: 30,
                clearance: 0.5,
                wingInset: 3,
                wingLength: 40,
                lidWingLength: 20,
                lidClearance: 1,
                dashLength: 5,
                dashGap: 3,
            };

            const loadSavedState = () => {
                try {
                    const saved = sessionStorage.getItem('bankerBoxState');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (e) { }
                return null;
            };

            const savedState = loadSavedState();

            const [dimensions, setDimensions] = useState(savedState?.dimensions || defaultDimensions);
            const [exportMode, setExportMode] = useState(savedState?.exportMode || 'screen');
            const [showLid, setShowLid] = useState(savedState?.showLid ?? true);
            const [showBottom, setShowBottom] = useState(savedState?.showBottom ?? true);
            const [useTabs, setUseTabs] = useState(savedState?.useTabs ?? true);

            // Save state to sessionStorage whenever it changes
            useEffect(() => {
                const state = { dimensions, exportMode, showLid, showBottom, useTabs };
                sessionStorage.setItem('bankerBoxState', JSON.stringify(state));
            }, [dimensions, exportMode, showLid, showBottom, useTabs]);

            const bottomSvgRef = useRef(null);
            const lidSvgRef = useRef(null);

            const { width, depth, height, lidHeight, materialThickness, tabWidth, tabSpacing, clearance, wingInset, wingLength, lidWingLength, lidClearance, dashLength, dashGap } = dimensions;

            const mt = materialThickness;

            const cutStyle = { stroke: '#000000', strokeWidth: 0.5, fill: 'none' };
            const foldStyle = { stroke: '#FF0000', strokeWidth: 0.5, fill: 'none' };
            const laserFoldStyle = { stroke: '#000000', strokeWidth: 0.5, fill: 'none' };

            // Generate multiple parallel fold lines to account for material thickness
            // offset: perpendicular offset direction ('up', 'down', 'left', 'right')
            // amount: the total offset between the two lines (usually 2*mt or 3*mt)
            const generateMultiFoldLine = (x1, y1, x2, y2, keyPrefix, offset, amount) => {
                const lines = [];
                // First fold line at original position
                lines.push(...generateDashedLine(x1, y1, x2, y2, `${keyPrefix}-1`));

                // Second fold line offset by amount
                let x1_2 = x1, y1_2 = y1, x2_2 = x2, y2_2 = y2;
                if (offset === 'up') {
                    y1_2 -= amount;
                    y2_2 -= amount;
                } else if (offset === 'down') {
                    y1_2 += amount;
                    y2_2 += amount;
                } else if (offset === 'left') {
                    x1_2 -= amount;
                    x2_2 -= amount;
                } else if (offset === 'right') {
                    x1_2 += amount;
                    x2_2 += amount;
                }
                lines.push(...generateDashedLine(x1_2, y1_2, x2_2, y2_2, `${keyPrefix}-2`));

                return lines;
            };

            // Generate dashed line as actual segments for laser cutting (center-aligned)
            const generateDashedLine = (x1, y1, x2, y2, keyPrefix) => {
                if (exportMode !== 'laser') {
                    return [<line key={keyPrefix} x1={x1} y1={y1} x2={x2} y2={y2} {...foldStyle} />];
                }

                const segments = [];
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / length;
                const unitY = dy / length;

                // Calculate centered dash pattern
                const dashCycle = dashLength + dashGap;
                const numFullDashes = Math.floor((length + dashGap) / dashCycle);
                const totalDashLength = numFullDashes * dashLength + (numFullDashes - 1) * dashGap;
                const startOffset = (length - totalDashLength) / 2;

                for (let i = 0; i < numFullDashes; i++) {
                    const segStart = startOffset + i * dashCycle;
                    const segEnd = segStart + dashLength;

                    segments.push(
                        <line
                            key={`${keyPrefix}-${i}`}
                            x1={x1 + unitX * segStart}
                            y1={y1 + unitY * segStart}
                            x2={x1 + unitX * segEnd}
                            y2={y1 + unitY * segEnd}
                            {...laserFoldStyle}
                        />
                    );
                }

                return segments;
            };

            // Calculate centered tab positions for an edge
            const calculateTabPositions = (edgeLength) => {
                if (edgeLength < tabWidth) return null;

                const numTabs = Math.max(1, Math.floor((edgeLength + tabSpacing) / (tabWidth + tabSpacing)));

                if (numTabs === 1) {
                    return { numTabs: 1, positions: [(edgeLength - tabWidth) / 2] };
                }

                const totalTabWidth = numTabs * tabWidth;
                const gap = (edgeLength - totalTabWidth) / (numTabs + 1);
                const positions = [];
                for (let i = 0; i < numTabs; i++) {
                    positions.push(gap + i * (tabWidth + gap));
                }
                return { numTabs, positions };
            };

            // Generate tab edge path segment (for inner panels with protruding tabs)
            const generateTabEdge = (startX, y, edgeWidth, direction) => {
                if (!useTabs) return `L ${startX + edgeWidth} ${y}`;
                const tabInfo = calculateTabPositions(edgeWidth);
                if (!tabInfo) return `L ${startX + edgeWidth} ${y}`;

                let path = '';
                let currentX = startX;

                for (let i = 0; i < tabInfo.numTabs; i++) {
                    const tabX = startX + tabInfo.positions[i];
                    path += ` L ${tabX} ${y}`;
                    if (direction === 'up') {
                        path += ` L ${tabX} ${y - mt}`;
                        path += ` L ${tabX + tabWidth} ${y - mt}`;
                    } else {
                        path += ` L ${tabX} ${y + mt}`;
                        path += ` L ${tabX + tabWidth} ${y + mt}`;
                    }
                    path += ` L ${tabX + tabWidth} ${y}`;
                }
                path += ` L ${startX + edgeWidth} ${y}`;
                return path;
            };

            // Generate vertical tab edge path segment
            const generateVerticalTabEdge = (x, startY, edgeHeight, direction) => {
                if (!useTabs) return `L ${x} ${startY + edgeHeight}`;
                const tabInfo = calculateTabPositions(edgeHeight);
                if (!tabInfo) return `L ${x} ${startY + edgeHeight}`;

                let path = '';

                for (let i = 0; i < tabInfo.numTabs; i++) {
                    const tabY = startY + tabInfo.positions[i];
                    path += ` L ${x} ${tabY}`;
                    if (direction === 'left') {
                        path += ` L ${x - mt} ${tabY}`;
                        path += ` L ${x - mt} ${tabY + tabWidth}`;
                    } else {
                        path += ` L ${x + mt} ${tabY}`;
                        path += ` L ${x + mt} ${tabY + tabWidth}`;
                    }
                    path += ` L ${x} ${tabY + tabWidth}`;
                }
                path += ` L ${x} ${startY + edgeHeight}`;
                return path;
            };

            // Generate slots in base panel
            const generateSlots = (startX, startY, length, direction) => {
                if (!useTabs) return [];
                const tabInfo = calculateTabPositions(length);
                if (!tabInfo) return [];

                const paths = [];
                const sc = clearance; // slot clearance

                for (let i = 0; i < tabInfo.numTabs; i++) {
                    const offset = tabInfo.positions[i];
                    if (direction === 'horizontal') {
                        paths.push(
                            <rect key={`slot-${i}`}
                                x={startX + offset - sc}
                                y={startY - sc / 2}
                                width={tabWidth + 2 * sc}
                                height={mt + sc}
                                {...cutStyle} />
                        );
                    } else {
                        paths.push(
                            <rect key={`slot-${i}`}
                                x={startX - sc / 2}
                                y={startY + offset - sc}
                                width={mt + sc}
                                height={tabWidth + 2 * sc}
                                {...cutStyle} />
                        );
                    }
                }
                return paths;
            };

            const generateBottomBox = (offsetX, offsetY) => {
                const elements = [];
                const mt = materialThickness;
                const fbFoldOffset = mt;
                const lrFoldOffset = mt;
                const fbSlotOffset = mt;
                const lrSlotOffset = clearance;
                const innerH = height;
                const wingH = wingLength;
                const clip = 2 * mt;
                const fbInset = 2 * mt;
                const lrInset = 2 * mt;

                const baseW = width + 4 * mt;
                const baseD = depth + 4 * mt;

                // Maximum extensions from the base fold rectangle to ensure everything stays positive
                const topExt = Math.max(height + fbFoldOffset + innerH + mt, wingH);
                const leftExt = height + lrFoldOffset + innerH + mt;

                const baseX = offsetX + leftExt;
                const baseY = offsetY + topExt;

                // ============ FRONT WALL + INNER PANEL ============
                // Wall starts from center fold line (baseY), measures height outward
                // Wall is height, then fbFoldOffset for fold, then innerH for inner panel with tabs
                const frontPath = `
                    M ${baseX} ${baseY}
                    L ${baseX} ${baseY - height}
                    L ${baseX + fbInset} ${baseY - height}
                    L ${baseX + fbInset} ${baseY - height - fbFoldOffset}
                    L ${baseX + fbInset} ${baseY - height - fbFoldOffset - innerH}
                    ${generateTabEdge(baseX + fbInset, baseY - height - fbFoldOffset - innerH, baseW - 2 * fbInset, 'up')}
                    L ${baseX + baseW - fbInset} ${baseY - height - fbFoldOffset}
                    L ${baseX + baseW - fbInset} ${baseY - height}
                    L ${baseX + baseW} ${baseY - height}
                    L ${baseX + baseW} ${baseY}
                `;
                elements.push(<path key="front-wall-inner" d={frontPath} {...cutStyle} />);

                elements.push(...generateMultiFoldLine(
                    baseX + fbInset + clip, baseY - height,
                    baseX + baseW - fbInset - clip, baseY - height,
                    'front-outer-fold', 'up', fbFoldOffset
                ));
                // ============ BACK WALL + INNER PANEL ============
                // Wall starts from center fold line (baseY + baseD), measures height outward
                const backPath = `
                    M ${baseX} ${baseY + baseD}
                    L ${baseX} ${baseY + baseD + height}
                    L ${baseX + fbInset} ${baseY + baseD + height}
                    L ${baseX + fbInset} ${baseY + baseD + height + fbFoldOffset}
                    L ${baseX + fbInset} ${baseY + baseD + height + fbFoldOffset + innerH}
                    ${generateTabEdge(baseX + fbInset, baseY + baseD + height + fbFoldOffset + innerH, baseW - 2 * fbInset, 'down')}
                    L ${baseX + baseW - fbInset} ${baseY + baseD + height + fbFoldOffset}
                    L ${baseX + baseW - fbInset} ${baseY + baseD + height}
                    L ${baseX + baseW} ${baseY + baseD + height}
                    L ${baseX + baseW} ${baseY + baseD}
                `;
                elements.push(<path key="back-wall-inner" d={backPath} {...cutStyle} />);

                elements.push(...generateMultiFoldLine(
                    baseX + fbInset + clip, baseY + baseD + height,
                    baseX + baseW - fbInset - clip, baseY + baseD + height,
                    'back-outer-fold', 'down', fbFoldOffset
                ));
                // ============ LEFT WALL (with wings) + INNER PANEL ============
                const leftWallPath = `
                    M ${baseX} ${baseY}
                    L ${baseX} ${baseY + mt}
                    L ${baseX - wingInset} ${baseY + mt - wingH}
                    L ${baseX - height + wingInset} ${baseY + mt - wingH}
                    L ${baseX - height} ${baseY + mt}
                    L ${baseX - height} ${baseY + lrInset}
                    L ${baseX - height - lrFoldOffset} ${baseY + lrInset}
                    L ${baseX - height - lrFoldOffset - innerH} ${baseY + lrInset}
                    ${generateVerticalTabEdge(baseX - height - lrFoldOffset - innerH, baseY + lrInset, baseD - 2 * lrInset, 'left')}
                    L ${baseX - height - lrFoldOffset} ${baseY + baseD - lrInset}
                    L ${baseX - height} ${baseY + baseD - lrInset}
                    L ${baseX - height} ${baseY + baseD - mt}
                    L ${baseX - height + wingInset} ${baseY + baseD - mt + wingH}
                    L ${baseX - wingInset} ${baseY + baseD - mt + wingH}
                    L ${baseX} ${baseY + baseD - mt}
                    L ${baseX} ${baseY + baseD}
                `;
                elements.push(<path key="left-wall-inner" d={leftWallPath} {...cutStyle} />);

                const lwx = baseX - height;
                elements.push(...generateMultiFoldLine(
                    lwx, baseY + lrInset + clip,
                    lwx, baseY + baseD - lrInset - clip,
                    'left-outer-fold', 'left', lrFoldOffset
                )); elements.push(...generateDashedLine(
                    baseX - height + clip, baseY + mt,
                    baseX - clip, baseY + mt,
                    'left-top-wing-fold'
                ));
                elements.push(...generateDashedLine(
                    baseX - height + clip, baseY + baseD - mt,
                    baseX - clip, baseY + baseD - mt,
                    'left-bottom-wing-fold'
                ));

                // ============ RIGHT WALL (with wings) + INNER PANEL ============
                const rightWallPath = `
                    M ${baseX + baseW} ${baseY}
                    L ${baseX + baseW} ${baseY + mt}
                    L ${baseX + baseW + wingInset} ${baseY + mt - wingH}
                    L ${baseX + baseW + height - wingInset} ${baseY + mt - wingH}
                    L ${baseX + baseW + height} ${baseY + mt}
                    L ${baseX + baseW + height} ${baseY + lrInset}
                    L ${baseX + baseW + height + lrFoldOffset} ${baseY + lrInset}
                    L ${baseX + baseW + height + lrFoldOffset + innerH} ${baseY + lrInset}
                    ${generateVerticalTabEdge(baseX + baseW + height + lrFoldOffset + innerH, baseY + lrInset, baseD - 2 * lrInset, 'right')}
                    L ${baseX + baseW + height + lrFoldOffset} ${baseY + baseD - lrInset}
                    L ${baseX + baseW + height} ${baseY + baseD - lrInset}
                    L ${baseX + baseW + height} ${baseY + baseD - mt}
                    L ${baseX + baseW + height - wingInset} ${baseY + baseD - mt + wingH}
                    L ${baseX + baseW + wingInset} ${baseY + baseD - mt + wingH}
                    L ${baseX + baseW} ${baseY + baseD - mt}
                    L ${baseX + baseW} ${baseY + baseD}
                `;
                elements.push(<path key="right-wall-inner" d={rightWallPath} {...cutStyle} />);

                const rwxRight = baseX + baseW + height;
                elements.push(...generateMultiFoldLine(
                    rwxRight, baseY + lrInset + clip,
                    rwxRight, baseY + baseD - lrInset - clip,
                    'right-outer-fold', 'right', lrFoldOffset
                )); elements.push(...generateDashedLine(
                    baseX + baseW + clip, baseY + mt,
                    baseX + baseW + height - clip, baseY + mt,
                    'right-top-wing-fold'
                ));
                elements.push(...generateDashedLine(
                    baseX + baseW + clip, baseY + baseD - mt,
                    baseX + baseW + height - clip, baseY + baseD - mt,
                    'right-bottom-wing-fold'
                ));

                // ============ CENTER FOLD LINE RECTANGLE ============
                elements.push(...generateDashedLine(baseX + clip, baseY, baseX + baseW - clip, baseY, 'center-fold-front'));
                elements.push(...generateDashedLine(baseX + baseW, baseY + clip, baseX + baseW, baseY + baseD - clip, 'center-fold-right'));
                elements.push(...generateDashedLine(baseX + baseW - clip, baseY + baseD, baseX + clip, baseY + baseD, 'center-fold-back'));
                elements.push(...generateDashedLine(baseX, baseY + baseD - clip, baseX, baseY + clip, 'center-fold-left'));

                // ============ SLOTS IN BASE ============
                elements.push(...generateSlots(baseX + fbInset, baseY + fbSlotOffset, baseW - 2 * fbInset, 'horizontal').map((el, i) =>
                    React.cloneElement(el, { key: `base-front-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + fbInset, baseY + baseD - fbSlotOffset - mt, baseW - 2 * fbInset, 'horizontal').map((el, i) =>
                    React.cloneElement(el, { key: `base-back-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + lrSlotOffset, baseY + lrInset, baseD - 2 * lrInset, 'vertical').map((el, i) =>
                    React.cloneElement(el, { key: `base-left-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + baseW - lrSlotOffset - mt, baseY + lrInset, baseD - 2 * lrInset, 'vertical').map((el, i) =>
                    React.cloneElement(el, { key: `base-right-slot-${i}` })
                ));

                return <g key="bottom-box">{elements}</g>;
            };

            const generateLid = (offsetX, offsetY) => {
                const elements = [];

                // Lid is slightly larger to fit over the box
                // Box base is (width + 4*mt) × (depth + 4*mt), lid needs clearance over that
                // Plus lid's own double walls (another 4*mt)
                const lidW = width + 8 * mt + lidClearance;
                const lidD = depth + 8 * mt + lidClearance;
                const lh = lidHeight;
                const fbFoldOffset = mt;
                const lrFoldOffset = mt;
                const fbSlotOffset = mt;
                const lrSlotOffset = clearance;
                const innerH = lh;
                const wingH = lidWingLength;
                const clip = 2 * mt;
                const fbInset = 2 * mt;
                const lrInset = 2 * mt;

                // Maximum extensions from the base fold rectangle to ensure everything stays positive
                const topExt = Math.max(lh + fbFoldOffset + innerH + mt, wingH);
                const leftExt = lh + lrFoldOffset + innerH + mt;

                const baseX = offsetX + leftExt;
                const baseY = offsetY + topExt;

                // ============ FRONT LID WALL + INNER ============
                // Wall is lh, then mt for fold, then innerH for inner panel with tabs
                const frontPath = `
                    M ${baseX} ${baseY}
                    L ${baseX} ${baseY - lh}
                    L ${baseX + fbInset} ${baseY - lh}
                    L ${baseX + fbInset} ${baseY - lh - fbFoldOffset}
                    L ${baseX + fbInset} ${baseY - lh - fbFoldOffset - innerH}
                    ${generateTabEdge(baseX + fbInset, baseY - lh - fbFoldOffset - innerH, lidW - 2 * fbInset, 'up')}
                    L ${baseX + lidW - fbInset} ${baseY - lh - fbFoldOffset}
                    L ${baseX + lidW - fbInset} ${baseY - lh}
                    L ${baseX + lidW} ${baseY - lh}
                    L ${baseX + lidW} ${baseY}
                `;
                elements.push(<path key="lid-front" d={frontPath} {...cutStyle} />);
                elements.push(...generateMultiFoldLine(
                    baseX + fbInset + clip, baseY - lh,
                    baseX + lidW - fbInset - clip, baseY - lh,
                    'lid-front-outer-fold', 'up', fbFoldOffset
                ));
                // ============ BACK LID WALL + INNER ============
                // Wall is lh, then mt for fold, then innerH for inner panel with tabs
                const backPath = `
                    M ${baseX} ${baseY + lidD}
                    L ${baseX} ${baseY + lidD + lh}
                    L ${baseX + fbInset} ${baseY + lidD + lh}
                    L ${baseX + fbInset} ${baseY + lidD + lh + fbFoldOffset}
                    L ${baseX + fbInset} ${baseY + lidD + lh + fbFoldOffset + innerH}
                    ${generateTabEdge(baseX + fbInset, baseY + lidD + lh + fbFoldOffset + innerH, lidW - 2 * fbInset, 'down')}
                    L ${baseX + lidW - fbInset} ${baseY + lidD + lh + fbFoldOffset}
                    L ${baseX + lidW - fbInset} ${baseY + lidD + lh}
                    L ${baseX + lidW} ${baseY + lidD + lh}
                    L ${baseX + lidW} ${baseY + lidD}
                `;
                elements.push(<path key="lid-back" d={backPath} {...cutStyle} />);
                elements.push(...generateMultiFoldLine(
                    baseX + fbInset + clip, baseY + lidD + lh,
                    baseX + lidW - fbInset - clip, baseY + lidD + lh,
                    'lid-back-outer-fold', 'down', fbFoldOffset
                ));
                // ============ LEFT LID WALL + INNER ============
                // ============ LEFT LID WALL + INNER ============

                // Left lid wall with wings and inner panel as one continuous path
                // Top wing -> outer edge -> mt fold -> inner panel (with tabs) -> mt fold -> outer edge -> bottom wing
                const leftLidWallPath = `
                    M ${baseX} ${baseY}
                    L ${baseX} ${baseY + mt}
                    L ${baseX - wingInset} ${baseY + mt - wingH}
                    L ${baseX - lh + wingInset} ${baseY + mt - wingH}
                    L ${baseX - lh} ${baseY + mt}
                    L ${baseX - lh} ${baseY + lrInset}
                    L ${baseX - lh - lrFoldOffset} ${baseY + lrInset}
                    L ${baseX - lh - lrFoldOffset - innerH} ${baseY + lrInset}
                    ${generateVerticalTabEdge(baseX - lh - lrFoldOffset - innerH, baseY + lrInset, lidD - 2 * lrInset, 'left')}
                    L ${baseX - lh - lrFoldOffset} ${baseY + lidD - lrInset}
                    L ${baseX - lh} ${baseY + lidD - lrInset}
                    L ${baseX - lh} ${baseY + lidD - mt}
                    L ${baseX - lh + wingInset} ${baseY + lidD - mt + wingH}
                    L ${baseX - wingInset} ${baseY + lidD - mt + wingH}
                    L ${baseX} ${baseY + lidD - mt}
                    L ${baseX} ${baseY + lidD}
                `;
                elements.push(<path key="lid-left-wall-inner" d={leftLidWallPath} {...cutStyle} />);

                const llwx = baseX - lh;
                elements.push(...generateMultiFoldLine(
                    llwx, baseY + lrInset + clip,
                    llwx, baseY + lidD - lrInset - clip,
                    'lid-left-outer-fold', 'left', lrFoldOffset
                )); elements.push(...generateDashedLine(
                    baseX - lh + clip, baseY + mt,
                    baseX - clip, baseY + mt,
                    'lid-left-top-wing-fold'
                ));
                elements.push(...generateDashedLine(
                    baseX - lh + clip, baseY + lidD - mt,
                    baseX - clip, baseY + lidD - mt,
                    'lid-left-bottom-wing-fold'
                ));

                // ============ RIGHT LID WALL + INNER ============
                // ============ RIGHT LID WALL + INNER ============
                const rlwx = baseX + lidW; // inner edge of right lid wall (at base fold)

                // Right lid wall with wings and inner panel as one continuous path
                // Top wing -> outer edge -> mt fold -> inner panel (with tabs) -> mt fold -> outer edge -> bottom wing
                const rightLidWallPath = `
                    M ${baseX + lidW} ${baseY}
                    L ${baseX + lidW} ${baseY + mt}
                    L ${baseX + lidW + wingInset} ${baseY + mt - wingH}
                    L ${baseX + lidW + lh - wingInset} ${baseY + mt - wingH}
                    L ${baseX + lidW + lh} ${baseY + mt}
                    L ${baseX + lidW + lh} ${baseY + lrInset}
                    L ${baseX + lidW + lh + lrFoldOffset} ${baseY + lrInset}
                    L ${baseX + lidW + lh + lrFoldOffset + innerH} ${baseY + lrInset}
                    ${generateVerticalTabEdge(baseX + lidW + lh + lrFoldOffset + innerH, baseY + lrInset, lidD - 2 * lrInset, 'right')}
                    L ${baseX + lidW + lh + lrFoldOffset} ${baseY + lidD - lrInset}
                    L ${baseX + lidW + lh} ${baseY + lidD - lrInset}
                    L ${baseX + lidW + lh} ${baseY + lidD - mt}
                    L ${baseX + lidW + lh - wingInset} ${baseY + lidD - mt + wingH}
                    L ${baseX + lidW + wingInset} ${baseY + lidD - mt + wingH}
                    L ${baseX + lidW} ${baseY + lidD - mt}
                    L ${baseX + lidW} ${baseY + lidD}
                `;
                elements.push(<path key="lid-right-wall-inner" d={rightLidWallPath} {...cutStyle} />);

                const rlwxRight = baseX + lidW + lh;
                elements.push(...generateMultiFoldLine(
                    rlwxRight, baseY + lrInset + clip,
                    rlwxRight, baseY + lidD - lrInset - clip,
                    'lid-right-outer-fold', 'right', lrFoldOffset
                )); elements.push(...generateDashedLine(
                    baseX + lidW + clip, baseY + mt,
                    baseX + lidW + lh - clip, baseY + mt,
                    'lid-right-top-wing-fold'
                ));
                elements.push(...generateDashedLine(
                    baseX + lidW + clip, baseY + lidD - mt,
                    baseX + lidW + lh - clip, baseY + lidD - mt,
                    'lid-right-bottom-wing-fold'
                ));

                // ============ CENTER FOLD LINE RECTANGLE ============
                elements.push(...generateDashedLine(baseX + clip, baseY, baseX + lidW - clip, baseY, 'lid-center-fold-front'));
                elements.push(...generateDashedLine(baseX + lidW, baseY + clip, baseX + lidW, baseY + lidD - clip, 'lid-center-fold-right'));
                elements.push(...generateDashedLine(baseX + lidW - clip, baseY + lidD, baseX + clip, baseY + lidD, 'lid-center-fold-back'));
                elements.push(...generateDashedLine(baseX, baseY + lidD - clip, baseX, baseY + clip, 'lid-center-fold-left'));

                // ============ SLOTS IN LID ============
                elements.push(...generateSlots(baseX + fbInset, baseY + fbSlotOffset, lidW - 2 * fbInset, 'horizontal').map((el, i) =>
                    React.cloneElement(el, { key: `lid-front-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + fbInset, baseY + lidD - fbSlotOffset - mt, lidW - 2 * fbInset, 'horizontal').map((el, i) =>
                    React.cloneElement(el, { key: `lid-back-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + lrSlotOffset, baseY + lrInset, lidD - 2 * lrInset, 'vertical').map((el, i) =>
                    React.cloneElement(el, { key: `lid-left-slot-${i}` })
                ));
                elements.push(...generateSlots(baseX + lidW - lrSlotOffset - mt, baseY + lrInset, lidD - 2 * lrInset, 'vertical').map((el, i) =>
                    React.cloneElement(el, { key: `lid-right-slot-${i}` })
                ));

                return <g key="lid">{elements}</g>;
            };

            // Calculate total pattern sizes for the patterns
            const boxInnerH = height;
            const boxFbFold = mt;
            const boxLrFold = mt;
            const boxBaseW = width + 4 * mt;
            const boxBaseD = depth + 4 * mt;
            const boxTopExt = Math.max(height + boxFbFold + boxInnerH + mt, wingLength);
            const boxLeftExt = height + boxLrFold + boxInnerH + mt;
            const bottomWidth = boxLeftExt * 2 + boxBaseW;
            const bottomHeight = boxTopExt * 2 + boxBaseD;

            const lidW = width + 8 * mt + lidClearance;
            const lidD = depth + 8 * mt + lidClearance;
            const lidInnerH = lidHeight;
            const lidFbFold = mt;
            const lidLrFold = mt;
            const lidTopExt = Math.max(lidHeight + lidFbFold + lidInnerH + mt, lidWingLength);
            const lidLeftExt = lidHeight + lidLrFold + lidInnerH + mt;
            const lidTotalWidth = lidLeftExt * 2 + lidW;
            const lidTotalHeight = lidTopExt * 2 + lidD;

            const padding = 50; // preview padding
            const exportPadding = 2; // small offset from 0,0 for export
            const svgWidth = Math.max(showBottom ? bottomWidth : 0, showLid ? lidTotalWidth : 0) + 2 * padding;
            const svgHeight = (showBottom ? bottomHeight : 0) + (showLid ? lidTotalHeight : 0) + (showBottom && showLid ? padding : 0) + 2 * padding;

            // Export SVG with pattern aligned to top-left
            const exportSVG = useCallback((patternType) => {
                const svgElement = patternType === 'bottom' ? bottomSvgRef.current : lidSvgRef.current;
                if (!svgElement) return;

                // Get the group for this pattern type
                const group = svgElement.querySelector('g');
                if (!group) return;

                // Calculate dimensions and offset
                const patternWidth = patternType === 'bottom' ? bottomWidth : lidTotalWidth;
                const patternHeight = patternType === 'bottom' ? bottomHeight : lidTotalHeight;

                // Create new SVG with pattern at top-left (using mm units for laser software)
                const svgW = patternWidth + exportPadding * 2;
                const svgH = patternHeight + exportPadding * 2;

                const offsetX = exportPadding - padding;
                const offsetY = exportPadding - padding;

                let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}mm" height="${svgH}mm" viewBox="0 0 ${svgW} ${svgH}">
<g transform="translate(${offsetX}, ${offsetY})">
${group.outerHTML}
</g>
</svg>`;

                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `banker-box-${patternType}-${width}x${depth}x${height}mm-${exportMode}.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, [width, depth, height, exportMode, bottomWidth, bottomHeight, lidTotalWidth, lidTotalHeight, padding, exportPadding]);

            const exportBottom = useCallback(() => exportSVG('bottom'), [exportSVG]);
            const exportLid = useCallback(() => exportSVG('lid'), [exportSVG]);

            const handleDimensionChange = (key, value) => {
                const numValue = parseFloat(value) || 0;
                setDimensions(prev => ({ ...prev, [key]: numValue }));
            };

            return (
                <div className="min-h-screen bg-gray-100 p-6">
                    <div className="max-w-7xl mx-auto">
                        <h1 className="text-3xl font-bold text-gray-800 mb-6">Banker Box Generator</h1>

                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            <div className="bg-white rounded-lg shadow-lg p-6 overflow-y-auto" style={{ maxHeight: '90vh' }}>
                                <h2 className="text-xl font-bold mb-4">Interior Dimensions (mm)</h2>

                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Inside Width</label>
                                        <input type="number" value={dimensions.width} onChange={(e) => handleDimensionChange('width', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Inside Depth</label>
                                        <input type="number" value={dimensions.depth} onChange={(e) => handleDimensionChange('depth', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Inside Height</label>
                                        <input type="number" value={dimensions.height} onChange={(e) => handleDimensionChange('height', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Lid Wall Height</label>
                                        <input type="number" value={dimensions.lidHeight} onChange={(e) => handleDimensionChange('lidHeight', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Wing Length (Bottom)</label>
                                        <input type="number" value={dimensions.wingLength} onChange={(e) => handleDimensionChange('wingLength', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Wing Length (Lid)</label>
                                        <input type="number" value={dimensions.lidWingLength} onChange={(e) => handleDimensionChange('lidWingLength', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>

                                    <hr className="my-4" />
                                    <h3 className="text-lg font-bold">Advanced Settings</h3>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Material Thickness</label>
                                        <input type="number" step="0.1" value={dimensions.materialThickness} onChange={(e) => handleDimensionChange('materialThickness', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Tab Width</label>
                                        <input type="number" value={dimensions.tabWidth} onChange={(e) => handleDimensionChange('tabWidth', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Tab Spacing</label>
                                        <input type="number" value={dimensions.tabSpacing} onChange={(e) => handleDimensionChange('tabSpacing', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Lid Clearance</label>
                                        <input type="number" step="0.1" value={dimensions.lidClearance} onChange={(e) => handleDimensionChange('lidClearance', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Assembly Clearance</label>
                                        <input type="number" step="0.1" value={dimensions.clearance} onChange={(e) => handleDimensionChange('clearance', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Wing Corner Inset</label>
                                        <input type="number" step="0.5" value={dimensions.wingInset} onChange={(e) => handleDimensionChange('wingInset', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Dash Length</label>
                                        <input type="number" step="0.5" value={dimensions.dashLength} onChange={(e) => handleDimensionChange('dashLength', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Dash Gap</label>
                                        <input type="number" step="0.5" value={dimensions.dashGap} onChange={(e) => handleDimensionChange('dashGap', e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-md" />
                                    </div>

                                    <hr className="my-4" />
                                    <h3 className="text-lg font-bold">Options</h3>
                                    <div className="space-y-2">
                                        <label className="flex items-center gap-2">
                                            <input type="checkbox" checked={useTabs} onChange={(e) => setUseTabs(e.target.checked)} className="w-4 h-4" />
                                            <span className="text-sm">Use Tabs & Slots</span>
                                        </label>
                                    </div>

                                    <hr className="my-4" />
                                    <h3 className="text-lg font-bold">Display</h3>
                                    <div className="flex items-center gap-4">
                                        <label className="flex items-center gap-2">
                                            <input type="checkbox" checked={showBottom} onChange={(e) => setShowBottom(e.target.checked)} className="w-4 h-4" />
                                            <span className="text-sm">Bottom</span>
                                        </label>
                                        <label className="flex items-center gap-2">
                                            <input type="checkbox" checked={showLid} onChange={(e) => setShowLid(e.target.checked)} className="w-4 h-4" />
                                            <span className="text-sm">Lid</span>
                                        </label>
                                    </div>

                                    <hr className="my-4" />
                                    <h3 className="text-lg font-bold">Export Mode</h3>
                                    <div className="space-y-2">
                                        <label className="flex items-center gap-2">
                                            <input type="radio" name="exportMode" checked={exportMode === 'screen'} onChange={() => setExportMode('screen')} className="w-4 h-4" />
                                            <span className="text-sm">Screen (Red fold lines)</span>
                                        </label>
                                        <label className="flex items-center gap-2">
                                            <input type="radio" name="exportMode" checked={exportMode === 'laser'} onChange={() => setExportMode('laser')} className="w-4 h-4" />
                                            <span className="text-sm">Laser (Dashed fold lines)</span>
                                        </label>
                                    </div>

                                    <div className="flex gap-2 mt-4">
                                        <button onClick={exportBottom} className="flex-1 px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">
                                            Export Bottom
                                        </button>
                                        <button onClick={exportLid} className="flex-1 px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">
                                            Export Lid
                                        </button>
                                    </div>
                                </div>

                                <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                    <h3 className="font-bold mb-2">Legend</h3>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex items-center gap-2">
                                            <div className="w-8 h-0.5 bg-black"></div>
                                            <span>Cut</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            {exportMode === 'laser' ? (
                                                <div className="w-8 h-0.5 border-t-2 border-dashed border-black"></div>
                                            ) : (
                                                <div className="w-8 h-0.5 bg-red-500"></div>
                                            )}
                                            <span>Fold</span>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 p-4 bg-blue-50 rounded-lg text-sm">
                                    <h3 className="font-bold mb-2">Pattern Size</h3>
                                    <p>Bottom: {bottomWidth.toFixed(1)} × {bottomHeight.toFixed(1)} mm</p>
                                    <p>Lid: {lidTotalWidth.toFixed(1)} × {lidTotalHeight.toFixed(1)} mm</p>
                                </div>
                            </div>

                            <div className="lg:col-span-2 space-y-6">
                                {showBottom && (
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h2 className="text-xl font-bold mb-4">Bottom Box</h2>
                                        <div className="overflow-auto border border-gray-200 rounded-lg bg-gray-50 p-4" style={{ maxHeight: '40vh' }}>
                                            <svg ref={bottomSvgRef} width={bottomWidth + padding * 2} height={bottomHeight + padding * 2} viewBox={`0 0 ${bottomWidth + padding * 2} ${bottomHeight + padding * 2}`} xmlns="http://www.w3.org/2000/svg" className="bg-white">
                                                {generateBottomBox(padding, padding)}
                                            </svg>
                                        </div>
                                    </div>
                                )}
                                {showLid && (
                                    <div className="bg-white rounded-lg shadow-lg p-6">
                                        <h2 className="text-xl font-bold mb-4">Lid</h2>
                                        <div className="overflow-auto border border-gray-200 rounded-lg bg-gray-50 p-4" style={{ maxHeight: '40vh' }}>
                                            <svg ref={lidSvgRef} width={lidTotalWidth + padding * 2} height={lidTotalHeight + padding * 2} viewBox={`0 0 ${lidTotalWidth + padding * 2} ${lidTotalHeight + padding * 2}`} xmlns="http://www.w3.org/2000/svg" className="bg-white">
                                                {generateLid(padding, padding)}
                                            </svg>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<BankerBoxGenerator />);
    </script>
</body>

</html>